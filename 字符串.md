#############################两字符串求和问题########################
leectode_67/leetcode_415
#####思路
while (j >= 0 || i >= 0 || carry != 0)
1、由低位向高位，对两数字符循环求和，如果高位溢出，则进行补零操作（10进制为例，二进制大同小异）
   carry += i > 0 ? s1.charAt(i--) - '0' : 0
   carry += j > 0 ? s2.charAt(j--) - '0' : 0
2、保存进位值，并参与下次计算循环（10进制为例，二进制大同小异）
    carry /= 10
3、求和值保存入栈（10进制为例，二进制大同小异）
    stack.push(carry % 10)
4、循环结束，弹栈并拼接字符串
    new StringBuilders().append(stack.pop())
#############################字符串压缩问题########################    
leetcode_443: ["a","a","b","b","c","c","c"] ==> ["a","2","b","2","c","3"]
#####思路
1、双指针循环字符串，判断快指针是否等于慢指针，快指针后移
    1.1 如果相等，且计数器自增
    1.2 如果不相等，慢指针后移，快指针赋值给慢指针
        1.2.1 计数器不等于初始值，慢指针后移，统计值赋值慢指针，慢指针后移，计数器重置
2、循环结束，如果计数器的值不为初始值，慢指针后移，统计值赋值给慢指针
#############################字符串单词统计问题######################## 
leetcode_434：  输入: "Hello, my name is John"   输出: 5  解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
#####思路
定义单词计数器(结果值)，定义字符计数器(用来排除多个连续空格)
1、以空格作为单词的判断标准，字符串trim去除首尾空格
2、循环遍历字符串
for (int i=0; i<s.length; i++)
    2.1 如果字符不等于''，字符计数器自增
    if (s.charAt(i) != ' ') temp ++    
        2.1.1 如果是最后一个字符，单词计数器自增
        if (i == s.length() - 1) count++
    2.2 如果字符等于''，并且字符计数器不等于0，则单词计数器自增，字符计数器重置
    if (s.charAt(i) == ' ' && temp != 0) count++; temp=0;
#############################字符串第一个唯一字符问题########################
LeetCode_387: 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
#####思路:空间换时间（利用map数据结构）
1、循环字符串，统计各个字符出现的频率，并保存到Map中
for (char c : s.toCharArray()) {map.put(c, map.getOrDefault(c, 0)+1)}
2、循环字符串，找到出现次数为1的字符的下标位置并返回
for (int i=0; i<s.length(); i++) {if (map.get(s.charAt(i)) == 1) return i;}
#############################回文数问题########################
LeetCode_125（字符串）: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。输入: "A man, a plan, a canal: Panama" 输出: true
LeetCode_9（整数）: 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
#####思路:双指针==>字符串
1、定义头指针从头开始循环，直到遇到非字母或者非数字的字符
while (head < tail && !Character.isLetterOrDigit(s.charAt(head))) head ++;
2、定义尾指针从尾部开始循环，直到遇到非字母或者非数字的字符
while (head < tail && !Character.isLetterOrDigit(s.charAt(tail))) tail --;
3、判断指针所指的字符是否相等，若不相等则不为回文数
if (Character.toLowerCase(s.charAt(head)) != Character.toLowerCase(s.charAt(tail))) return false;
#####思路:数学算法==>整数
1、循环分解每个位置的数
    x /= 10
    pop = x % 10
2、循环拼接每个位置的数
    res = res * 10 + pop
3、判断拼接的数是否和原数相等
#############################验证有效的括号########################
LeetCode_20: 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。       
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
#####思路:使用栈结构
1、循环字符串的所有字符，每个字符压栈之前需要判断栈是否为空
    1.1 栈为空则直接入栈
    1.2 栈不为空，分两种情况：
        1.2.1 如果栈顶元素，与预压栈符号成对，则弹出栈顶符号
        1.2.2 反之，压栈
2、循环结束，如果栈不为空则说明不是有效的括号
 #############################最长公共前缀问题#############################
 LeetCode_14: 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 ""。输入: ["flower","flow","flight"]  输出: "fl"
#####思路:暴力解法
1、选取第一个字符串为基准值，循环除基准值外的其他字符串
String stand = strs[0];
for (int i=1; i<str.length(); i++)
2、循环基准值和非基准值，依次比较非基准值和基准值的每个字符
int j = 0;
for (; j < strs[i].length() && j < stand.length(); j++)
    2.1 如果不相等则跳出循环
    if (stand.charAt(j) != strs[i].charAt(j)) break;
3、循环结束更新最新基准值
stand = stand.substring(0, j);
#############################最长公共前缀问题#############################
LeetCode_459: 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。
输入: "abcabcabcabc"  输出: True  解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)
#####思路:数学思路
// 假设 S 由 s 重复 N (N>1)此组成，则 S+S由s重复2N次组成，
// 去掉头和尾相当于破坏了2个s, 此时 S+S[1:-1] 仍包含(2N-2)个s
// 若 2N-2 == 0，说明N=1，S由1个s组成，返回false
// 若 2N-2>0，说明 N>=2，S由两个以上s组成，返回true
#############################字符串翻转问题#############################
LeetCode_344: 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
LeetCode_345: 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。
#####思路:双指针
1、定义头指针和尾指针，循环判断指向值是否相等，若相等则交换位置，否则继续循环(344)
1、定义头指针循环左侧数据，遇到元音字母，跳出循环(345)
2、定义尾指针循环右侧数据，遇到元音字母，跳出循环(345)
3、交换左右两侧的元音字母。继续下一次循环，直到头尾指针相遇或者交叉(345)
#############################字符串首次出现的位置问题#############################
LeetCode_28: 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
#####思路:KPM搜索算法
1、求出每个KPM字符串的dp数组
2、利用dp数组快速查找KPM字符串







